\documentclass[11pt,a4paper,oneside]{article}

\newcommand{\ftitle}{OSPFv3 Routing Attack}
\newcommand{\fauthor}{
Roelf Wichertjes (1008016) \&\\ Kaj Wortel (0991586)
}
\newcommand{\coursecode}{2IC80}
\newcommand{\coursename}{Lab Offensive Computer Security}
\newcommand{\footertitle}{2WF80 - Homework Set 2}
\newcommand{\preamble}{}


\usepackage[includeheadfoot,top=0.5in,bottom=0.5in]{geometry}
\usepackage{mathtools}
\usepackage[T1]{fontenc}
\usepackage[normalem]{ulem}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{xparse}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{calc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{hhline}          % For using double lines in tables
\usepackage{multido}         % For using multido
\usepackage{graphicx}        % For using pictures
\usepackage{float}
\usepackage{cases}           % For using fancy case statements

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{#1}}
\fancyhf{}
\lhead{{\textsc{\fancyplain{}{\rightmark }}}}
\rhead{{\raisebox{-0.30\height}{\includegraphics[height=20pt]{tuelogo.pdf}}}}
\cfoot{{\thepage}}
\lfoot{{\fauthor}}
\rfoot{{\textsc{\coursecode { -} \ftitle}}}
\renewcommand\headrulewidth{1pt}
\renewcommand\footrulewidth{1pt}
\setlength{\headheight}{26pt}
\setlength{\headsep}{0.75in}
\addtolength{\footskip}{0.50in}
\addtolength{\textheight}{-1.25in}

\fancyheadoffset{0.5in}
\fancyfootoffset{0.5in}
\newcommand{\longdiv}[2]{$\strut#1$\kern.25em\smash{\raise.3ex\hbox{$\big)$}}$\mkern-8mu\overline{\enspace\strut#2}$}
\newcommand{\tab}[1][1]{\leavevmode{\parindent=#1em\indent}}

% Commands to directly create sections with custom labels
\newcommand{\lsection}[2]{\section{#1}\label{sec:#2}}
\newcommand{\lsubsection}[2]{\subsection{#1}\label{sec:#2}}
\newcommand{\lsubsubsection}[2]{\subsubsection{#1}\label{sec:#2}}


\fancypagestyle{plain} {
\fancyhf{}
\lhead{{\textsc{\fancyplain{}{\rightmark }}}}
\rhead{{\raisebox{-0.30\height}{\includegraphics[height=20pt]{tuelogo.pdf}}}}
\cfoot{{\thepage}}
\lfoot{{\fauthor}}
\rfoot{{\textsc{\coursecode { -} \ftitle}}}
\renewcommand\headrulewidth{1pt}
\renewcommand\footrulewidth{1pt}
\setlength{\headheight}{26pt}
\setlength{\headsep}{0.75in}
\addtolength{\footskip}{0.50in}
\addtolength{\textheight}{-1.25in}

\fancyheadoffset{0.5in}
\fancyfootoffset{0.5in}
}


\newcommand{\headrulecolour}{0.823529412,0.125490196,0.384313725}
\let\oldheadrule\headrule
\renewcommand{\headrule}{{\color[rgb]{\headrulecolour}\oldheadrule}}

\preamble

\newcommand{\ssection}[1]{\section*{#1}\markright{#1}}


\title{\ftitle\\\coursecode { -} \coursename}
\author{\fauthor}


\begin{document}
    \maketitle\thispagestyle{fancy}
    \newpage
    \tableofcontents
    \newpage


    \lsection{Introduction}{intro}
    %Why interesting to do technical challenging, what do we need?


    \lsection{Scenario}{scenario}
    Gentco is one of the leading manufacturers of dashing Bowler Hats. Recently the price of unique, high quality Swiss leather that \textit{Gentco} relies on to make their most popular hat has gone up.\\
    Management at \textit{Gentco} believes that their competitor, \textit{Dapper Inc.}, has been bribing \textit{Gentco}'s exclusive supplier in order to raise prices for Gentco. This would be in direct violation of the contract Gentco has with the supplier. Gentco management is reluctant to make such a direct claim without proof since, if they are wrong, this could deteriate the relationship even further.\\
    That's why they want us to obtain proof of this. To do so, they want us to investigate \textit{Dapper Inc.} and figure out if they are indeed paying off \textit{Gentco}'s supplier.\\
    We started off by obtaining a dump of \textit{Dapper Inc.}'s DNS records. One of the system admins had forgotten to disable zone transfers, so these were easily obtainable.\\
    By looking at these records we discovered that \textit{Dapper Inc.} runs a very modern network, where everything uses IPv6. Undeterred, we started scanning the systems we discovered in the DNS dump. The networking team at \textit{Dapper Inc.} has the fortress locked up quite tight, but htey made one mistake. One of their core routers' management interfaces isn't firewalled off.\\
    The SSH deamon's banner reveals that \textit{Dapper Inc.} uses some of the latest routers byso \textit{ACME Networks} Recently it was discovered that this vendor includes a hardcoded backdoor account with full privileges in all their routers. Using this account, we gained full access to this core router.\\
    Now that we've got a foothold in their network, we need to obtain information. This router uses a Linux based OS assisted by application specific integrated circuits for high performance routing. This presents a problem. We cannot see the traffic passing through the router. The hardware is, however, capable of terminating GRE based tunnels and treating them as if they are physical ports. We also were able to perform some network reconnaisance and obtain a wealth of information about the structure of \textit{Dapper Inc.}'s network. This information is presented in \textit{Section \ref{sec:env_setup}}. Sadly, the rest of the network is secured quite well and we are unable to move beyond the router we are currently occupying.\\
    While investigating \textit{Dapper Inc.}'s network, we discovered a recent blog post by \textit{Example Corp}, the makers of a \textit{Software as a Service} accounting application. They published a case study detailing how their AI-powered analytics helped \textit{Dapper Inc.} save several million dollars. It turns out that, although they seem to care a lot about their AI technology, they do not care about security. They aren't even using HTTPS! In other words: a golden oppertunity.\\
    The plan is simple: If we can hijack \textit{Example Corp}'s /48 inside of \textit{Dapper Inc.}'s network and re-route it to a server under our control, we can capture the passwords of \textit{Dapper Inc.}'s accountants and confirm or deny that \textit{Dapper Inc.} is paying \textit{Gentco}' s supplier by accessing \textit{Dapper Inc's} financial reconds.


    \lsection{Objectives}{objectives}
    The main objective is to spy on and redirect traffic in \textit{Dapper Inc.}'s network. To achieve this, we assume the following case:
    \begin{itemize}
        \item Full control over router C2 (see \textit{Section \ref{sec:env_setup}}).
        \item Method exploits OSPFv3 to re-route traffic to \textit{Example Corp} from the \textit{Accounting Dept.} via C2.
        \item Send traffic destined for \textit{Example Corp} to an attacker-controlled server.
        \item This server has been connected via a GRE tunnel to C2.
    \end{itemize}


    \lsection{Environmental setup}{env_setup}
    TODO:
    - Describe the setup of the environment (show picture).
    - Explain rationale behind it.


    \lsection{Protocol}{protocol}
    Before coding up an attack, we must first understand the protocol and discover where it's weaknesses and strengths are. The results of this orientative phase are documented in our wiki \cite{wiki}.
    \lsubsection{OSPFv3 Packet}{ospfv3_packet}
    The most important (sub-)packates of the protocol are:
    \begin{itemize}
        \item \textbf{Hello Packet}\\
        Used to keep the link alive.
        \item \textbf{Database Description Packets}\\
        This packet is used in the database exchange protocol, where this packet announces the available entries.
        \item \textbf{Link State Request}\\
        This packet is used in the database exchange protocol, where this packet announces the needed entries.
        \item \textbf{Link State Update}\\
        This packet is used to keep the link weights up to date, and used in the database exchange protocol to initialize entries.
        \item \textbf{Link State Acknowledgement}\\
        Packet for acknowledging Link State Update packets
    \end{itemize}
    \lsubsection{LSA Packet}{lsa_packet}
    All \textit{Link State} (LS) OSPF packets which we used contain \textit{Link State Anouncement} (LSA) packets. There are multiple LSA types (see our wiki\cite{wiki} for detailed info), however the most important fields are:
    \begin{itemize}
        \item \textbf{Age}\\
        How long a package has lived so far.
        \item \textbf{Checksum}\\
        The Fletcher's checksum\cite{fletcher} of the LSA.
        \item \textbf{Sequence ID}\\
        The sequence number of this LSA. Is increased in every \textit{LS Update Packet}
        \item \textbf{metric}\\
        The weight/cost of a link.
    \end{itemize}

    \lsubsubsection{LSA priority}{lsa_priority}
    To save processing time, the equality of two LSA's is not determined by checking both packets byte by byte, but by certain fields in the packet. Also, if there is already an old packet in the database then it should be removed. On the other hand, a LSA packet returning to the originating router should not initiate a fightback LSA (see \textit{section \ref{sec:fightback}}). For this purpose, the OSPFv3 protocol defines priority and equality of two packets.
    A LSA packet \texttt{A} has a higer priority than LSA packet \texttt{B} if (in order):
    \begin{enumerate}
        \item The \textit{Sequence ID} of packet \texttt{A} is higher than the \textit{Sequence ID} of packet \texttt{B}
        \item The \textit{Checksum} of packet \texttt{A} is higher than the checksum of packet \texttt{B}.
        \item The \textit{Age} of packet \texttt{A} is equal to the maximum age and the \textit{Age} of packet \texttt{B} is not equal to the maximum age.
        \item The difference between the \textit{Age} of packet \texttt{A} and \texttt{B} is more than the maximum allowed difference, and the \textit{Age} of \texttt{A} is higher.
    \end{enumerate}
    If none of these cases hold for either of the packets, then the two LSAs are regarded equal.
    \lsection{Parser}{parser}
    One of the key challenges in actually executing this attack is interpreting and generating OSPFv3 packets.
    Many of the security-research oriented sniffing/interception/packet-forging tools, such as scapy and libtins, include a parser and emitter for OSPFv2.
    However, the only open-source implementations of OSPFv3 we could find were embedded inside of actual OSPFv3 daemons.
    These implementations of the protocol are not suited to our needs since they are heavily integrated in their respective projects.

    We elected to write our own parser/emitter from scratch.
    This took a lot of time and effort since OSPFv3 is a rather low-level protocol and contains a lot of quirks that can be traced back to OSPFv2.
    Nonetheless, we managed to create this novel piece of software.
    Our parser/emitter has been written to be very modular and self-contained, thus enabling it to be easily re-used by other projects in the future.


    \lsection{Attack engineering}{attack}
    The router we have compromised is used as backup link, so the links are very costly and is therefore not choosen as a node in any path. Hence initially we cannot control any packets in the network. To change this, we need to convince the other routers that our connection is the fastest one. We can achieve this by `telling' the other routers that our route has the lowest cost. If these routers believe us, then all packets are routed through our router, hence resulting in full control over the network.

    We can `tell' the other routers the weight of a link using a \textit{Link State Update} (LSU) packet. If they believe our update message, then they will also update their lowest cost path accordingly.
    
    In this way we can let routers dislike certain routes and redirect all traffic to our router. Once a message is send to our router, we can send to our server outside the network. In this way we have obtained a man in the middle position inside the network.
    
    However, OSPF has a nasty fightback mechanism which will directly repair the original weight if a faulty weight was announced. We also need some additional information regarding the network. Both will be discussed in this section.

    \lsubsection{Attack preperation}{attack_prep}
    Before we can perform an attack on an OSPF network, we need to gather some information about the network.
    In order to pull of our attack, we need to know a number of things about the network topology:
    \begin{itemize}
        \item A list of links to attack.
        \item The router ID, address and interface on which at least one OSPF neighbor of the router we control is located.

        This neighbor must \textit{not} be one of the endpoints of a link we wish to attack.
        We need a "thrid party" neighbor who will flood any \textit{Link State Update} we send it to the rest of the network.
        \item A copy of the link state database.

        Although we know which links to attack, we need to have a copy of the actual most-recent LSA of all routers involved in the attack.
    \end{itemize}

    In order to obtain the neighbor we need, we first listen for OSPF hello packets.
    These are sent every few seconds and we simply extract the information we need from the first one we capture that matches our requirements.

    Next we need to trigger that neighbor to exchange its Link State DataBase.
    We can do this by sending a Database Description packet with an invalid sequence number.
    This makes the neighbor think that something went wrong during the previous exchange and will cause it to perform a full database exchange with the router we are located on.
    By capturing the packets from both sides, we can build up a list of LSAs that are in the database.

    However, the DataBase Exchange does not contain the actual LSAs that we need.
    Luckily it contains enough information for us to create a Link State Request packet to request the neighbor to transmit its entire database.

    \lsubsection{Fightback mechanism}{fightback}
    The fightback mechanism is initiated when a router receives a LSU packet which states that it was originated by the receiving router, and is newer than the last LSA the router has send for that link (see \textit{Section \ref{sec:lsa_priority}}). This router then creates a LSU which is newer than the received LSU and with the correct data. By doing so, the network is secure against packet corruption, but is it also secure agains an attacker?

    There are three main approaches in attacking the fightback mechanism. The first is to prevent the fightback from being sent. This is impossible since it requires us to have control over all links to this router, which we don't have.

    The second approach is to not let the fightback LSA reach the other routers. This is alsmost the same as the first approach, since it requires us to have control over all links from this router.

    That leaves us with the third approach, which is letting the other routers ignore the fightback LSA. This already happens naturally when two routers flood the same LSA to another third router. In this case, the second arriving packet will be ignored (see \textit{Section \ref{sec:lsa_priority}}). So we have to forge an LSA which is regarded equal compared to the fightback LSA -- but has the modified link weight -- and it must arrives earlier than the fightback LSA.
    
    Since every router ignores LSAs for a certain link for a certain amount of time after receiving one, the fightback must wait for this timeout to pass. To be sure the timeout has passed on all routers in the network, some extra wait time is introduced for the fightback LSA. We can use this to ensure that our packet will arrive before the fightback.

	\lsubsection{Checksum}{checksum}
    The first condition is a bit harder. First of all, we can predict the exact fightback LSA, especialy the priority fields (\textit{Sequence ID} and \textit{Checksum}). The \textit{Sequence ID} is easy to forge, but forging the checksum is impossible if we are not allowed to modify any content of the LSA. Luckily, there are some reserved zero bytes which are documented as ``\text{Should be set to zero [...] and must be ignored when receiv[ed]}'' \cite[appendix A.3.1]{rfc-5340}.
    
    The \textit{Fletcher-16 bit}\cite{fletcher} checksum is used as basis checksum algorithm Afterwards, some extra computations are added to simplify the verification algorithm. This last step can be easily reverse engineered, so this step will be ignored in the rest of the paper for the sake of simplicity. The fletcher checksum however requires some linear algebra.
    
    
    \lsubsubsection{Forging LSA Fletcher-16 checksum}{flet-algo}
    Let's first explain how this algorithm works. This algorithm initializes two 8-bit integers using modulo 255 \textit{c0} and $c_1$. Then every byte is added to $c_0$, and then $c_0$ is added to $c_1$. Finally, these two values are appended and create the 16-bit checksum.
	    
	    Now let $m[i]$ be the $i^{th}$ byte of the expected message, $m'[i]$ the $i^{th}$ byte of the (unmodified) forged message, $\ell$ the length of the message, and $x$ and $y$ the indices of the two bytes which we can choose freely . Then we can rewrite $c_0$ and $c_1$ to:
	    %
\begin{equation}\label{eq:1}
\begin{cases}
	c_0 = \sum\limits_{i=0}^{\ell} m[i] \mod{255}\\
	c_1 = \sum\limits_{i=0}^{\ell} (\ell - i) \cdot m[i] \mod{255}
\end{cases}
\end{equation}

    		Now we also want this to hold for our forged message. We also know that $m[x] = m[y] = 0$. Therefore we can simplify \hyperref[eq:1]{Equation 1} to:
\begin{equation}\label{eq:2}
\begin{cases}
	c_0 = c_0' + m'[x] + m'[y] \mod{255}\\
	c_1 = c_1' + (\ell - x) \cdot m'[x] + (\ell - y) \cdot m'[y] \mod{255}
\end{cases}
\end{equation}
	
    	We have now obtained linear system with two equations and two unknowns. Solving the system in \hyperref[eq:2]{Equation 2} yields:
    
\begin{equation}\label{eq:3}
\begin{cases}
    m'[x] = \dfrac{\ \ (\ell - x) \cdot (c_0 - c_0') - (c_1 - c_1')}{y - x} \mod{255}\\
    m'[y] = \dfrac{-(\ell - y) \cdot (c_0 - c_0') + (c_1 - c_1')}{y - x} \mod{255}
\end{cases}
\end{equation}
		
    		Note that since the result must be an integer modulo 255. In this case this means that we can only forge the checksum if the inverse of the difference of $x$ and $y$ in modulo 255 exists.
    
    \lsubsection{Sending the attack}{send_attack}
    		We can now forge both LSAs where especially the second one has an equal values in the \textit{Sequence ID} and \textit{Checksum} fields compared to the expected fightback LSA.
	    With this, we can send the first LSA to update the routing tables of the other routers and trigger the fightback LSA from the targeted router. Then we wait until the timeout has passed and send our second LSA just before the fightback which updates the sequence numbers in the other routing tables, but is ignored by the target router since it is not ``newer'' compared to the fightback LSA. Finally the fightback LSA is send and ignored by all other routers since it is evaluated as ``equal'' compared to our forged LSA by the other routers.
	    
	\lsubsection{Persistence}{persistence}
		The attack is easily made persistent over time by listening to LSU packets. If there is an LSA in these LSU packets which deviates from the specified values for that link, then the attack is simply repeated.
		Additionally, one can repeat the attack just before the LSA update is expected. For example, every LSA will be updated after a set amount of time (depends on configuration, default is 30 minutes).
		
    		
    \lsection{Discussion}{discussion}
		
		
		
    \lsection{Results}{results}
		
		
		
    %%%%%%%% References %%%%%%%%
    \begin{thebibliography}{999}
        \bibitem{ref}
        title,
        author,
        publisher,
        Country e.d.
        edition,
        date,
        url

        \bibitem{wiki}
        OSPFv3 Protocol Wiki,
        R.Wichertjes \& K.Wortel,
        \url{https://github.com/rewbycraft/OSPFv3DisguisedLSA/wiki}

        \bibitem{fletcher}
        Fletcher's Checksum,
        Wikipedia,
        December 2018,
        \url{https://en.wikipedia.org/wiki/Fletcher\%27s_checksum}


        \bibitem{rfc-6860}
        OSPFv3 Spec. - RFC 6860,
        Network Working Group,
        Y. Yang at al.,
        January 2013,
        \url{https://tools.ietf.org/html/rfc6860}

        \bibitem{rfc-6845}
        OSPFv3 Spec. - RFC 6845,
        Network Working Group,
        N.Sheth at al.,
        January 2013,
        \url{https://tools.ietf.org/html/rfc6845}

        \bibitem{rfc-5340}
        OSPFv3 Spec. - RFC 5340,
        Network Working Group,
        R. Coltun at al.,
        July 2008,
        \url{https://tools.ietf.org/html/rfc5340}
        
        \bibitem{rfc-4861}
        IPv6 Neighbor Discovery - RFC 4861,
        T.Narten at al.,
        September 2007
        https://tools.ietf.org/html/rfc4861

        \bibitem{rfc-2460}
        IPv6 Spec. - RFC 2460,
        Network Working Group,
        S. Deering at al.,
        December 1998,
        \url{https://tools.ietf.org/html/rfc2460}

        \bibitem{rfc-2328}
        OSPFv2 Spec. - RFC 2328,
        Network Working Group,
        J.Moy at al.,
        April 1998,
        \url{https://tools.ietf.org/html/rfc2328}

        \bibitem{rfc-1191}
        Path MTU Discovery - RFC 1191,
        Network Working Group,
        J. Mogul at al.,
        November 1998,
        \url{https://tools.ietf.org/html/rfc1191}

        \bibitem{rfc-905}
        Transport Protocol - RFC 905,
        Network Working Group,
        April 1984,
        \url{https://tools.ietf.org/html/rfc905}

        \bibitem{rfc-892}
        Transport Protocol - RFC 892,
        Network Working Group,
        December 1983,
        \url{https://tools.ietf.org/html/rfc892}

    \end{thebibliography}


\end{document}